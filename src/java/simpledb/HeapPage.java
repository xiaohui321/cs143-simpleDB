package simpledb;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

/**
 * Each instance of HeapPage stores data for one page of HeapFiles and
 * implements the Page interface that is used by BufferPool.
 * 
 * @see HeapFile
 * @see BufferPool
 * 
 */
public class HeapPage implements Page {

    final HeapPageId pid;

    final TupleDesc td;

    final byte header[];

    final Tuple tuples[];

    final int numSlots;

    byte[] oldData;

    private final Byte oldDataLock = new Byte((byte) 0);

    private TransactionId HeapPageTid;

    private boolean isDirty;

    /**
     * Create a HeapPage from a set of bytes of data read from disk. The format
     * of a HeapPage is a set of header bytes indicating the slots of the page
     * that are in use, some number of tuple slots. Specifically, the number of
     * tuples is equal to:
     * <p>
     * floor((BufferPool.getPageSize()*8) / (tuple size * 8 + 1))
     * <p>
     * where tuple size is the size of tuples in this database table, which can
     * be determined via {@link Catalog#getTupleDesc}. The number of 8-bit
     * header words is equal to:
     * <p>
     * ceiling(no. tuple slots / 8)
     * <p>
     * 
     * @see Database#getCatalog
     * @see Catalog#getTupleDesc
     * @see BufferPool#getPageSize()
     */
    public HeapPage(final HeapPageId id, final byte[] data) throws IOException {
	isDirty = false;
	HeapPageTid = null;
	pid = id;
	td = Database.getCatalog().getTupleDesc(id.getTableId());
	numSlots = getNumTuples();
	DataInputStream dis = new DataInputStream(
	        new ByteArrayInputStream(data));

	// allocate and read the header slots of this page
	header = new byte[getHeaderSize()];
	for (int i = 0; i < header.length; i++)
	    header[i] = dis.readByte();

	tuples = new Tuple[numSlots];
	try {
	    // allocate and read the actual records of this page
	    for (int i = 0; i < tuples.length; i++)
		tuples[i] = readNextTuple(dis, i);
	}
	catch (NoSuchElementException e) {
	    e.printStackTrace();
	}
	dis.close();

	setBeforeImage();
    }

    /**
     * Retrieve the number of tuples on this page.
     * 
     * @return the number of tuples on this page
     */
    private int getNumTuples() {
	return (int) Math.floor(BufferPool.PAGE_SIZE * 8
	        / (td.getSize() * 8 + 1));
    }

    /**
     * Computes the number of bytes in the header of a page in a HeapFile with
     * each tuple occupying tupleSize bytes
     * 
     * @return the number of bytes in the header of a page in a HeapFile with
     *         each tuple occupying tupleSize bytes
     */
    private int getHeaderSize() {
	return (int) Math.ceil(numSlots / 8.0);
    }

    /**
     * Return a view of this page before it was modified -- used by recovery
     */
    @Override
    public HeapPage getBeforeImage() {
	try {
	    byte[] oldDataRef = null;
	    synchronized (oldDataLock) {
		oldDataRef = oldData;
	    }
	    return new HeapPage(pid, oldDataRef);
	}
	catch (IOException e) {
	    e.printStackTrace();
	    // should never happen -- we parsed it OK before!
	    System.exit(1);
	}
	return null;
    }

    @Override
    public void setBeforeImage() {
	synchronized (oldDataLock) {
	    oldData = getPageData().clone();
	}
    }

    /**
     * @return the PageId associated with this page.
     */
    @Override
    public HeapPageId getId() {
	return pid;
    }

    /**
     * Suck up tuples from the source file.
     */
    private Tuple readNextTuple(final DataInputStream dis, final int slotId)
	    throws NoSuchElementException {
	// if associated bit is not set, read forward to the next tuple, and
	// return null.
	if (!isSlotUsed(slotId)) {
	    for (int i = 0; i < td.getSize(); i++)
		try {
		    dis.readByte();
		}
		catch (IOException e) {
		    throw new NoSuchElementException(
			    "error reading empty tuple");
		}
	    return null;
	}

	// read fields in the tuple
	Tuple t = new Tuple(td);
	RecordId rid = new RecordId(pid, slotId);
	t.setRecordId(rid);
	try {
	    for (int j = 0; j < td.numFields(); j++) {
		Field f = td.getFieldType(j).parse(dis);
		t.setField(j, f);
	    }
	}
	catch (java.text.ParseException e) {
	    e.printStackTrace();
	    throw new NoSuchElementException("parsing error!");
	}

	return t;
    }

    /**
     * Generates a byte array representing the contents of this page. Used to
     * serialize this page to disk.
     * <p>
     * The invariant here is that it should be possible to pass the byte array
     * generated by getPageData to the HeapPage constructor and have it produce
     * an identical HeapPage object.
     * 
     * @see #HeapPage
     * @return A byte array correspond to the bytes of this page.
     */
    @Override
    public byte[] getPageData() {
	int len = BufferPool.getPageSize();
	ByteArrayOutputStream baos = new ByteArrayOutputStream(len);
	DataOutputStream dos = new DataOutputStream(baos);

	// create the header of the page
	for (byte element : header)
	    try {
		dos.writeByte(element);
	    }
	    catch (IOException e) {
		// this really shouldn't happen
		e.printStackTrace();
	    }

	// create the tuples
	for (int i = 0; i < tuples.length; i++) {
	    // empty slot
	    if (!isSlotUsed(i)) {
		for (int j = 0; j < td.getSize(); j++)
		    try {
			dos.writeByte(0);
		    }
		    catch (IOException e) {
			e.printStackTrace();
		    }
		continue;
	    }
	    // non-empty slot
	    for (int j = 0; j < td.numFields(); j++) {
		Field f = tuples[i].getField(j);
		try {
		    f.serialize(dos);
		}
		catch (IOException e) {
		    e.printStackTrace();
		}
	    }
	}

	// padding
	int zerolen = BufferPool.getPageSize()
	        - (header.length + td.getSize() * tuples.length); // - numSlots
	                                                          // *
	                                                          // td.getSize();
	byte[] zeroes = new byte[zerolen];
	try {
	    dos.write(zeroes, 0, zerolen);
	}
	catch (IOException e) {
	    e.printStackTrace();
	}

	try {
	    dos.flush();
	}
	catch (IOException e) {
	    e.printStackTrace();
	}

	return baos.toByteArray();
    }

    /**
     * Static method to generate a byte array corresponding to an empty
     * HeapPage. Used to add new, empty pages to the file. Passing the results
     * of this method to the HeapPage constructor will create a HeapPage with no
     * valid tuples in it.
     * 
     * @return The returned ByteArray.
     */
    public static byte[] createEmptyPageData() {
	int len = BufferPool.getPageSize();
	return new byte[len]; // all 0
    }

    /**
     * Delete the specified tuple from the page; the tuple should be updated to
     * reflect that it is no longer stored on any page.
     * 
     * @throws DbException
     *             if this tuple is not on this page, or tuple slot is already
     *             empty.
     * @param t
     *            The tuple to delete
     */
    public void deleteTuple(final Tuple t) throws DbException {
	// The pageId does not match or slot marked unused
	if (!t.getRecordId().getPageId().equals(pid))
	    throw new DbException("Tuple not in this page");
	if (!isSlotUsed(t.getRecordId().tupleno()))
	    throw new DbException("Tuple not in this page");

	// mark corresponding header bit as not used
	markSlotUsed(t.getRecordId().tupleno(), false);

	// delete corresponding tuple
	tuples[t.getRecordId().tupleno()] = null;
    }

    /**
     * Adds the specified tuple to the page; the tuple should be updated to
     * reflect that it is now stored on this page.
     * 
     * @throws DbException
     *             if the page is full (no empty slots) or tupledesc is
     *             mismatch.
     * @param t
     *            The tuple to add.
     */
    public void insertTuple(final Tuple t) throws DbException {
	if (getNumEmptySlots() == 0)
	    throw new DbException("Page is full");
	if (!t.getTupleDesc().equals(td))
	    throw new DbException(
		    "Tuple descriptor mismatches for new tuple inserted");

	// find the next free slot
	int i;
	for (i = 0; i < numSlots; i++)
	    if (!isSlotUsed(i))
		break;

	markSlotUsed(i, true);

	// Create corresponding RID for inserting tuple
	RecordId Rid = new RecordId(pid, i);
	t.setRecordId(Rid);
	tuples[i] = t;
    }

    /**
     * Marks this page as dirty/not dirty and record that transaction that did
     * the dirtying
     */
    @Override
    public void markDirty(final boolean dirty, final TransactionId tid) {
	isDirty = dirty;
	HeapPageTid = tid;
    }

    /**
     * Returns the tid of the transaction that last dirtied this page, or null
     * if the page is not dirty
     */
    @Override
    public TransactionId isDirty() {
	if (isDirty)
	    return HeapPageTid;
	else
	    return null;
    }

    /**
     * Returns the number of empty slots on this page.
     */
    public int getNumEmptySlots() {
	int numEmptySlots = 0;
	int checkedSlots = 0;
	// for each byte on header
	for (byte element : header) {
	    byte[] b = new byte[] { element };
	    BigInteger bi = new BigInteger(b);
	    // check each bit on this byte
	    for (int i = 0; i < 8; i++)
		if (checkedSlots < numSlots && !bi.testBit(i)) {
		    numEmptySlots++;
		    checkedSlots++;
		}
	}
	return numEmptySlots;
    }

    /**
     * Returns true if associated slot on this page is filled.
     */
    public boolean isSlotUsed(final int i) {
	if (i > numSlots || i < 0)
	    throw new IllegalArgumentException("argument i is incorrect");

	int index = (int) Math.floor(i / 8.0);
	byte[] b = new byte[] { header[index] };

	BigInteger bi = new BigInteger(b);
	return bi.testBit(i % 8);
    }

    /**
     * Abstraction to fill or clear a slot on this page.
     */
    private void markSlotUsed(final int i, final boolean value) {
	if (i > numSlots || i < 0)
	    throw new IllegalArgumentException("argument i is incorrect");

	int index = (int) Math.floor(i / 8.0);
	int slotbit = i % 8;
	// the new byte at i/8 position of header[] byte array
	int newHeaderByte = 0;

	if (value)
	    newHeaderByte = header[index] | 1 << slotbit;
	else
	    newHeaderByte = header[index] & ~(1 << slotbit);

	header[index] = (byte) newHeaderByte;
    }

    /**
     * @return an iterator over all tuples on this page (calling remove on this
     *         iterator throws an UnsupportedOperationException) (note that this
     *         iterator shouldn't return tuples in empty slots!)
     */
    public Iterator<Tuple> iterator() {
	List<Tuple> filledSlotsList = new ArrayList<Tuple>();
	for (int i = 0; i < tuples.length; i++)
	    if (isSlotUsed(i))
		filledSlotsList.add(tuples[i]);

	return filledSlotsList.iterator();
    }

    public boolean hasFreeSlots() {
	return getNumEmptySlots() > 0;
    }
}
